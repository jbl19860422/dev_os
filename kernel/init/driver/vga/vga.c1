#include "vga.h"
int iCurRow = 0;
int iCurCol = 0;
extern void DisplayInt(int a);
#define NULL 0
void PrintChar(int iRow, int iCol, char cColor, char cChar)
{
	WORD wTmp;
	*((char *)&wTmp) = cChar;
	*((char *)&wTmp+1) = cColor;
    vVGA[VGA_LINE_COUNT*iRow+iCol] = wTmp;
}

void PrintWord(short data)
{
	char sMsg[5];
	sMsg[4] = '\0';
	char *p = &data;
	int i;
	char tmp = (p[1]&0xf0)>>4;
	sMsg[0] = tmp>=10?(tmp+'A'-10):(tmp+'0');
	tmp = p[1]&0x0f;
	sMsg[1] = tmp>=10?(tmp+'A'-10):(tmp+'0');
	tmp = (p[0]&0xf0)>>4;
	sMsg[2] = tmp>=10?(tmp+'A'-10):(tmp+'0');
	tmp = p[0]&0x0f;
	sMsg[3] = tmp>=10?(tmp+'A'-10):(tmp+'0');
	PrintMsg(sMsg);
}

void PrintDword(int iData)
{
	PrintMsg("0x");
	PrintWord((iData>>16)&0xffff);
	PrintWord(iData&0xffff);
}
void PrintMsg(char *sMsg)
{
	int i = 0;
	while(sMsg[i] != '\0')
	{	
		if(sMsg[i] == '\r')
		{
			iCurCol = 0;
			i++;
			continue;
		}
		else if(sMsg[i] == '\n')
		{
			iCurRow++;
			i++;
			continue;
		}
		/*
		else if(sMsg[i] == ' ')//空格
		{
			iCurCol++;
			if(iCurCol%VGA_LINE_COUNT == 0)
			{
				iCurCol = 0;
				iCurRow++;
			}
			i++;
			continue;
		}
		*/
		else if(sMsg[i] == '\t')
		{
			iCurCol+=4;
			if(iCurCol%VGA_LINE_COUNT == 0)
			{
				iCurCol = 0;
				iCurRow++;
			}
			i++;
			continue;
		}
		PrintChar(iCurRow, iCurCol, 0xc, sMsg[i]);
		iCurCol++;
		if(iCurCol%VGA_LINE_COUNT == 0)
		{
			iCurCol = 0;
			iCurRow++;
		}
		i++;
	}
	
	return;
}

void DrawRec(int x0, int y0, int x1, int y1, char cColor)
{
	int i = 0;
	int j = 0;
	for(j = y0; j < y1; j++)
	{
		for(i = x0; i < x1; i++)
		{
			PutPixel(i, j, cColor);
		}
	}
}

void InitPalette()
{
	int i;
	static RGB rgbTable[256] = 
	{
		{0xFF,0xFF,0xFF},
		{0xFF,0xFF,0xCC},
		{0xFF,0xFF,0x99},
		{0xFF,0xFF,0x66},
		{0xFF,0xFF,0x33},
		{0xFF,0xFF,0x00},
		{0xFF,0xCC,0xFF},
		{0xFF,0xCC,0xCC},
		{0xFF,0xCC,0x99},
		{0xFF,0xCC,0x66},
		{0xFF,0xCC,0x33},
		{0xFF,0xCC,0x00},
		{0xFF,0x99,0xFF},
		{0xFF,0x99,0xCC},
		{0xFF,0x99,0x99},
		{0xFF,0x99,0x66},
		{0xFF,0x99,0x33},
		{0xFF,0x99,0x00},
		{0xFF,0x66,0xFF},
		{0xFF,0x66,0xCC},
		{0xFF,0x66,0x99},
		{0xFF,0x66,0x66},
		{0xFF,0x66,0x33},
		{0xFF,0x66,0x00},
		{0xFF,0x33,0xFF},
		{0xFF,0x33,0xCC},
		{0xFF,0x33,0x99},
		{0xFF,0x33,0x66},
		{0xFF,0x33,0x33},
		{0xFF,0x33,0x00},
		{0xFF,0x00,0xFF},
		{0xFF,0x00,0xCC},
		{0xFF,0x00,0x99},
		{0xFF,0x00,0x66},
		{0xFF,0x00,0x33},
		{0xFF,0x00,0x00},
		{0x66,0xFF,0xFF},
		{0x66,0xFF,0xCC},
		{0x66,0xFF,0x99},
		{0x66,0xFF,0x66},
		{0x66,0xFF,0x33},
		{0x66,0xFF,0x00},
		{0x66,0xCC,0xFF},
		{0x66,0xCC,0xCC},
		{0x66,0xCC,0x99},
		{0x66,0xCC,0x66},
		{0x66,0xCC,0x33},
		{0x66,0xCC,0x00},
		{0x66,0x99,0xFF},
		{0x66,0x99,0xCC},
		{0x66,0x99,0x99},
		{0x66,0x99,0x66},
		{0x66,0x99,0x33},
		{0x66,0x99,0x00},
		{0x66,0x66,0xFF},
		{0x66,0x66,0xCC},
		{0x66,0x66,0x99},
		{0x66,0x66,0x66},
		{0x66,0x66,0x33},
		{0x66,0x66,0x00},
		{0x66,0x33,0xFF},
		{0x66,0x33,0xCC},
		{0x66,0x33,0x99},
		{0x66,0x33,0x66},
		{0x66,0x33,0x33},
		{0x66,0x33,0x00},
		{0x66,0x00,0xFF},
		{0x66,0x00,0xCC},
		{0x66,0x00,0x99},
		{0x66,0x00,0x66},
		{0x66,0x00,0x33},
		{0x66,0x00,0x00},
		{0xCC,0xFF,0xFF},
		{0xCC,0xFF,0xCC},
		{0xCC,0xFF,0x99},
		{0xCC,0xFF,0x66},
		{0xCC,0xFF,0x33},
		{0xCC,0xFF,0x00},
		{0xCC,0xCC,0xFF},
		{0xCC,0xCC,0xCC},
		{0xCC,0xCC,0x99},
		{0xCC,0xCC,0x66},
		{0xCC,0xCC,0x33},
		{0xCC,0xCC,0x00},
		{0xCC,0x99,0xFF},
		{0xCC,0x99,0xCC},
		{0xCC,0x99,0x99},
		{0xCC,0x99,0x66},
		{0xCC,0x99,0x33},
		{0xCC,0x99,0x00},
		{0xCC,0x66,0xFF},
		{0xCC,0x66,0xCC},
		{0xCC,0x66,0x99},
		{0xCC,0x66,0x66},
		{0xCC,0x66,0x33},
		{0xCC,0x66,0x00},
		{0xCC,0x33,0xFF},
		{0xCC,0x33,0xCC},
		{0xCC,0x33,0x99},
		{0xCC,0x33,0x66},
		{0xCC,0x33,0x33},
		{0xCC,0x33,0x00},
		{0xCC,0x00,0xFF},
		{0xCC,0x00,0xCC},
		{0xCC,0x00,0x99},
		{0xCC,0x00,0x66},
		{0xCC,0x00,0x33},
		{0xCC,0x00,0x00},
		{0x33,0xFF,0xFF},
		{0x33,0xFF,0xCC},
		{0x33,0xFF,0x99},
		{0x33,0xFF,0x66},
		{0x33,0xFF,0x33},
		{0x33,0xFF,0x00},
		{0x33,0xCC,0xFF},
		{0x33,0xCC,0xCC},
		{0x33,0xCC,0x99},
		{0x33,0xCC,0x66},
		{0x33,0xCC,0x33},
		{0x33,0xCC,0x00},
		{0x33,0x99,0xFF},
		{0x33,0x99,0xCC},
		{0x33,0x99,0x99},
		{0x33,0x99,0x66},
		{0x33,0x99,0x33},
		{0x33,0x99,0x00},
		{0x33,0x66,0xFF},
		{0x33,0x66,0xCC},
		{0x33,0x66,0x99},
		{0x33,0x66,0x66},
		{0x33,0x66,0x33},
		{0x33,0x66,0x00},
		{0x33,0x33,0xFF},
		{0x33,0x33,0xCC},
		{0x33,0x33,0x99},
		{0x33,0x33,0x66},
		{0x33,0x33,0x33},
		{0x33,0x33,0x00},
		{0x33,0x00,0xFF},
		{0x33,0x00,0xCC},
		{0x33,0x00,0x99},
		{0x33,0x00,0x66},
		{0x33,0x00,0x33},
		{0x33,0x00,0x00},
		{0x99,0xFF,0xFF},
		{0x99,0xFF,0xCC},
		{0x99,0xFF,0x99},
		{0x99,0xFF,0x66},
		{0x99,0xFF,0x33},
		{0x99,0xFF,0x00},
		{0x99,0xCC,0xFF},
		{0x99,0xCC,0xCC},
		{0x99,0xCC,0x99},
		{0x99,0xCC,0x66},
		{0x99,0xCC,0x33},
		{0x99,0xCC,0x00},
		{0x99,0x99,0xFF},
		{0x99,0x99,0xCC},
		{0x99,0x99,0x99},
		{0x99,0x99,0x66},
		{0x99,0x99,0x33},
		{0x99,0x99,0x00},
		{0x99,0x66,0xFF},
		{0x99,0x66,0xCC},
		{0x99,0x66,0x99},
		{0x99,0x66,0x66},
		{0x99,0x66,0x33},
		{0x99,0x66,0x00},
		{0x99,0x33,0xFF},
		{0x99,0x33,0xCC},
		{0x99,0x33,0x99},
		{0x99,0x33,0x66},
		{0x99,0x33,0x33},
		{0x99,0x33,0x00},
		{0x99,0x00,0xFF},
		{0x99,0x00,0xCC},
		{0x99,0x00,0x99},
		{0x99,0x00,0x66},
		{0x99,0x00,0x33},
		{0x99,0x00,0x00},
		{0x00,0xFF,0xFF},
		{0x00,0xFF,0xCC},
		{0x00,0xFF,0x99},
		{0x00,0xFF,0x66},
		{0x00,0xFF,0x33},
		{0x00,0xFF,0x00},
		{0x00,0xCC,0xFF},
		{0x00,0xCC,0xCC},
		{0x00,0xCC,0x99},
		{0x00,0xCC,0x66},
		{0x00,0xCC,0x33},
		{0x00,0xCC,0x00},
		{0x00,0x99,0xFF},
		{0x00,0x99,0xCC},
		{0x00,0x99,0x99},
		{0x00,0x99,0x66},
		{0x00,0x99,0x33},
		{0x00,0x99,0x00},
		{0x00,0x66,0xFF},
		{0x00,0x66,0xCC},
		{0x00,0x66,0x99},
		{0x00,0x66,0x66},
		{0x00,0x66,0x33},
		{0x00,0x66,0x00},
		{0x00,0x33,0xFF},
		{0x00,0x33,0xCC},
		{0x00,0x33,0x99},
		{0x00,0x33,0x66},
		{0x00,0x33,0x33},
		{0x00,0x33,0x00},
		{0x00,0x00,0xFF},
		{0x00,0x00,0xCC},
		{0x00,0x00,0x99},
		{0x00,0x00,0x66},
		{0x00,0x00,0x33},
		{0x00,0x00,0x00}
	};
	WritePortChar(0x03c8, 0);
	for(i = 0; i < 216; i++)
	{
		WritePortChar(0x03c9, rgbTable[i].r/4);
		WritePortChar(0x03c9, rgbTable[i].g/4);
		WritePortChar(0x03c9, rgbTable[i].b/4);
	}
}

void Set_BMP_Palette_Register(int index, RGB color)      //设置调色板寄存器…… 
{ 
    //WritePortChar(PALETTE_MASK,0xff); 
    WritePortChar(PALETTE_REGISTER_WR,index); 
    WritePortChar(PALETTE_DATA,color.r>>2); 
    WritePortChar(PALETTE_DATA,color.g>>2); 
    WritePortChar(PALETTE_DATA,color.b>>2); 
} 

int GetSupportMode(unsigned *p, int *iCount)
{
	short iRet = 0;
	struct VbeInfoBlock vbeInfo;
	PrintMsg("start to get\r\n");
	__asm__ (
		"CALL switch_protect_to_real\n\t"
		".code16\n\t"
		"MOVL %%EDI,%%EAX\n\t"
		"SHRL $4,%%EAX\n\t"
		"ANDW $0xFFFF,%%AX\n\t"
		"MOVW %%AX,%%ES\n\t"
		"ANDW $0x0F,%%DI\n\t"
		"MOVW $0x4F00,%%AX\n\t"
		"INT $0x10\n\t"
		"MOVW %%AX,%%BX\n\t"
		"CALL switch_real_to_protect\n\t"
		".code32\n\t"
		"MOVW %%BX,%%AX\n\t"
		:"=a" (iRet)
		:"D" (&vbeInfo)
	);
	PrintMsg("end get1\r\n");
	
	unsigned *m = vbeInfo.VideoModePtr;
	*iCount = 0;
	PrintMsg("m=");PrintDword(m);PrintMsg("\r\n");
	while(*m!=(unsigned)-1)
	{
		PrintDword(*m);
		p[*iCount] = *m;
		(*iCount)++;
		m++;
	}
	if(iRet == 0x004F)
	{
		return 0;
	}
	return -1;
}
char *g_pVideoBuff = NULL;
int CheckIfSupportMode(short mode)
{
	struct ModeInfo mode_info;
	short iRet = -1;
	__asm__ (
		"CALL switch_protect_to_real\n\t"
		".code16\n\t"
		"MOVL %%EDI,%%EAX\n\t"
		"SHRL $4,%%EAX\n\t"
		"ANDW $0xFFFF,%%AX\n\t"
		"MOVW %%AX,%%ES\n\t"
		"ANDW $0x0F,%%DI\n\t"
		"MOVW $0x4F01,%%AX\n\t"
		"INT $0x10\n\t"
		"MOVW %%AX,%%BX\n\t"
		"CALL switch_real_to_protect\n\t"
		"MOVW %%BX,%%AX\n\t"
		".code32\n\t"
		"NOP"
		:"=a" (iRet)
		:"D" (&mode_info), "c" (mode)
	);
	if(iRet == 0x004F)
	{
		PrintMsg("modeattr=");PrintDword(mode_info.ModeAttr);PrintMsg("\r\n");
		PrintMsg("memorymodel=");PrintDword(mode_info.MemoryModel);PrintMsg("\r\n");
		PrintMsg("XRes=");PrintDword(mode_info.XRes);PrintMsg("&YRes=");PrintDword(mode_info.YRes);PrintMsg("&BPP=");PrintDword(mode_info.BitsPerPixel);PrintMsg("\r\n");
		g_pVideoBuff = mode_info.PhyBasePtr;
		PrintMsg("videobuff=");PrintDword(g_pVideoBuff);PrintMsg("\r\n");
		return 0;
	}
	return -1;
}

void InitBmpPalette(BITMAPCOLOR *pColor, int iCount)
{
	int i = 0;
	RGB rgb;
	for(i = 0; i < iCount; i++)
	{
		rgb.r = pColor->red;
		rgb.g = pColor->green;
		rgb.b = pColor->blue;
		Set_BMP_Palette_Register(i, rgb);
		pColor++;
	}
}

void _DrawBmp(int x0, int y0, char *pBmpData, int iWidth, int iHeight)
{
	int i = 0;
	int j = 0;
	iWidth = ((iWidth+3)/4)*4;//每行都4字节对齐
	for(j = iHeight-1; j >= 0; j--)
	{
		for(i = 0; i < iWidth; i++)
		{
			PutPixel(x0+i, y0+j, pBmpData[(iHeight-1-j)*iWidth+i]);	
		}
		//每行结束修正位置 
	}
}

void PutPixel(int x, int y, char cColor)
{
	g_pVideoBuff[y*800+x] = cColor;
}

static inline void PutPixel888(int x, int y, char r, char g, char b)
{
	int tmpPos = 2400*y+3*x;
	g_pVideoBuff[tmpPos] = b;
	g_pVideoBuff[tmpPos+1] = g;
	g_pVideoBuff[tmpPos+2] = r;
}
void InitVGA()
{
	unsigned int old_mode = get_SVGA_mode();
	PrintMsg("old_mode=");PrintDword(old_mode);PrintMsg("\r\n");
	set_SVGA_mode(0x4115); /*硬件无关性初始化屏幕为640*480 256色模式*/
}
unsigned int get_SVGA_mode()
{
	unsigned int iRet = 0;
	__asm__ __volatile__(
		"CALL switch_protect_to_real\n\t"
		".code16\n\t"
		"MOVW $0x4F03,%%AX\n\t"
		"INT $0x10\n\t"
		"CALL switch_real_to_protect\n\t"
		".code32\n\t"
		"NOP"
		:"=b" (iRet)
		:
	);
	return iRet;
}

unsigned char set_SVGA_mode(int vmode) /*设置SVGA屏幕模式*/
{
	unsigned int iRet = 0;
	__asm__ __volatile__ (
		"CALL switch_protect_to_real\n\t"
		".code16\n\t"
		"MOVW $0x4F02,%%AX\n\t"
		"INT $0x10\n\t"
		"CALL switch_real_to_protect\n\t"
		".code32\n\t"
		"NOP"
		:"=a" (iRet)
		: "b" (vmode)
	);
	return (iRet&0x0000ff00)>>8;
}

void DrawBmp256(int x0, int y0, char *pBmpData)
{
	int iColorCount;
	int iDataCount = 0;
	char *pBmpDataBak = pBmpData;
	BITMAPFILEHEADER *pHeader = (BITMAPFILEHEADER *)pBmpData;
	pBmpData += sizeof_t(BITMAPFILEHEADER);
	BITMAPINFO *pInfo = (BITMAPINFO *)pBmpData;
	//PrintMsg("pInfo=");PrintDword((int)pInfo);PrintMsg("\r\n");
	//PrintDword(pInfo->width);PrintMsg("\r\n");
	//PrintDword(pInfo->height);
	pBmpData+=sizeof(BITMAPINFO);
	BITMAPCOLOR *pColor = pBmpData;
	iColorCount = (pHeader->Offbits-sizeof_t(BITMAPFILEHEADER)-sizeof_t(BITMAPINFO))/sizeof_t(BITMAPCOLOR);
	//PrintMsg("color count=");PrintDword(iColorCount);PrintMsg("\r\n");
	InitBmpPalette(pColor, iColorCount);
	pBmpData =pBmpDataBak+pHeader->Offbits;
	_DrawBmp(x0, y0, pBmpData, pInfo->width, pInfo->height);
	//InitPalette();//还原原有的色彩表
}

void _DrawBmp888(int x0, int y0, char *pBmpData, int iWidth, int iHeight)
{
	int i = 0;
	int j = 0;
	//iWidth = ((iWidth+3)/4)*4;//每行都4字节对齐
	for(j = iHeight-1; j >= 0; j--)
	{
		for(i = 0; i < iWidth; i++)
		{
			char *pPointData = &pBmpData[(iHeight-1-j)*iWidth*3+i*3];
			PutPixel888(x0+i, y0+j, pPointData[2], pPointData[1], pBmpData[0]);	
			//PutPixel888(x0+i,y0+j,pBmpData[j*iWidth+i], pBmpData[j*iWidth+i+1],pBmpData[j*iWidth+i+2]);
		}
		//每行结束修正位置 
	}
}

int max(int a, int b)
{
	return a>b?a:b;
}

int min(int a, int b)
{
	return a>b?b:a;
}


void DrawRec888(int x0, int y0, int x1, int y1, RGB color)
{
	int bigX = max(x0,x1);
	int bigY = max(y0,y1);
	int smlX = min(x0,x1);
	int smlY = min(y0,y1);
	int x = smlX;
	int y = smlY;
	for(x = smlX;x < bigX;x++)
	{
		for(y = smlY;y < bigY; y++)
		{
			PutPixel888(x, y, color.r, color.g, color.b);
		}
	}
}
void DrawLine(int x0, int y0, int x1, int y1, RGB color)
{
	int bigX = max(x0,x1);
	int bigY = max(y0,y1);
	int smlX = min(x0,x1);
	int smlY = min(y0,y1);
	int x = smlX;
	int y = smlY;
	for(;x < bigX;x++)
	{
		for(;y < bigY; y++)
		{
			PutPixel888(x, y, color.r, color.g, color.b);
		}
	}
}

int DrawBmp888(int x0, int y0, char *pBmpData)
{
	int iColorCount;
	int iDataCount = 0;
	char *pBmpDataBak = pBmpData;
	BITMAPFILEHEADER *pHeader = (BITMAPFILEHEADER *)pBmpData;
	pBmpData += sizeof_t(BITMAPFILEHEADER);
	BITMAPINFO *pInfo = (BITMAPINFO *)pBmpData;
	//PrintMsg("pInfo=");PrintDword((int)pInfo);PrintMsg("\r\n");
	//PrintDword(pInfo->width);PrintMsg("\r\n");
	//PrintDword(pInfo->height);
	//pBmpData+=sizeof(BITMAPINFO);
	//BITMAPCOLOR *pColor = pBmpData;
	//iColorCount = (pHeader->Offbits-sizeof_t(BITMAPFILEHEADER)-sizeof_t(BITMAPINFO))/sizeof_t(BITMAPCOLOR);
	//PrintMsg("color count=");PrintDword(iColorCount);PrintMsg("\r\n");
	//InitBmpPalette(pColor, iColorCount);
	pBmpData = pBmpDataBak + pHeader->Offbits;
	_DrawBmp888(x0, y0, pBmpData, pInfo->width, pInfo->height);
}
